#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "dict.h"
#include "readlongwords.h"


Dict *dctcreate();
Node *nodelookup(Dict *, char *);
Node **dct_resize(Node **, size_t, size_t);
void dctinsert(Dict *, char *);
void transfer(Node *, Node **, size_t);
void chain_node(Node *, Node **, size_t);
size_t hash_index(char *, size_t);
size_t dcthash(char *);


/*
 * This functions generates a collisinless index from the input string with 
 * the max dictionary size.
 *
 * Input:
 * 	char *str: target string
 *	size_t:    unsigned long represent the max capacity of target dictinary
 *
 * Output:
 * 	size_t index: the resulting unsigned long from this function
 * */
size_t hash_index(char *str, size_t cap)
{
	size_t index, hash;
	hash = dcthash(str);
	index = hash % cap;

	return index;
}


/*
 * Generates a hash from the incoming string.
 *
 * Input:
 * 	char *key: target string
 *
 * Output:
 * 	size_t code: a unsigned long generated by the target string and 
 * 		     this function logic
 * */
size_t dcthash(char *key)
{
	size_t code, i;
	
	code = 0;
	for(i = 0; i < 8 && key[i] != '\0'; i++)
	{
		code = key[i] + 31 * code;
	}
	return code;
}


/*
 * Creates a dynamic array
 *
 * Input:
 * 	None
 *
 * Output:
 * 	Dict *initialiaze: Dict heap pointer made here
 * */
Dict *dctcreate()
{
	size_t d_size;
	Dict *initialize;

	/* Constructor */
	d_size = 10; 		/* Inital array size */	

	initialize = (Dict *)malloc(sizeof(Dict));
	initialize->cap = d_size;
	initialize->arr = (Node **)calloc(d_size, sizeof(Node *));
	initialize->size = 0;

	return initialize;
}


/*
 * Read word by word from the fd pointer into the Dict pointer.
 * If words already exist in the dictionary pointer, this functin will
 * increament the int associated with where said word is found in the dict.
 *
 * Input:
 * 	Dict *dct: Dict pointer that will store words or/and total occurrences
 *
 * Output:
 * 	None
 * */
void load_words(Dict *dct, FILE *fd)
{
	char c;
	char *str;
	Node *exist_node;
	
	str = NULL;
	exist_node = NULL;

	/* Loading words */
	while((c = fgetc(fd)) != EOF)
	{
		ungetc(c, fd);
		str = read_long_words(fd);
		if(str != NULL)
		{
			/* See if the current string exist in the dict*/
			exist_node = nodelookup(dct, str);
			if(exist_node != NULL)
			{
				exist_node->val++;
			}
			else
			{
				dctinsert(dct, str);
			}	
		}
	}	
	/* Once done close file */
	fclose(fd);
}


/*
 * Insert string into target dictionary. Will resize to keep dictionary 
 * performantive
 *
 * Input:
 * 	Dict *dct: Dict pointer that will store target strings
 *
 * Oitput:
 * 	None	
 * */
void dctinsert(Dict *dct, char *string)
{
	size_t index;

	/* Create need entry */
	Node *new_node;
	new_node = NULL;

	/* Need resize? */
	if(dct->size >= dct->cap)
	{
		size_t neo_cap;
		neo_cap = (dct->cap) * 2;

		dct->arr = dct_resize(dct->arr, dct->cap, neo_cap);	
		dct->cap = neo_cap;
	}

	/* Getting the proper collisionless key for new node*/
	index = hash_index(string, dct->cap);
	
	/* New node */
	new_node = (Node *)malloc(sizeof(Node));	
	new_node->string = string;
	new_node->val = 1;
	new_node->next = NULL;

	dct->size++;

	/* Need Chaining? */
	if(dct->arr[index] != NULL)
	{
		chain_node(new_node, dct->arr, index);
	}
	else
	{
		dct->arr[index] = new_node;
	}
	new_node = NULL; /* Reduce hanging value */
}


/*
 * Create a new heap array with a different size and transfer any and 
 * all contains to the new array accordingly from the incoming 
 * heap array.
 *
 * Input:
 * 	Node **node_arr: incoming heap array
 * 	size_t cap: incoming array total index
 * 	size_t new_cap: desired siae for the new array
 *
 * Output:
 * 	Node **new_node_arr: address of the new array with the new size but
 * 		             contains the old data from the old array
 * */
Node **dct_resize(Node **node_arr, size_t cap, size_t new_cap)
{
	size_t iterate;

	/* Need to create tmp Node arr for transfer */
	Node **new_node_arr;
	new_node_arr = (Node **)calloc(new_cap, sizeof(Node *));	

	/* Trying to find the index on old array where Node linked list exist */
	for(iterate = 0; iterate < cap; iterate++)
	{
		if(node_arr[iterate] != NULL)
		{
			/* Put old content to new array */
			transfer(node_arr[iterate], new_node_arr, new_cap);	
		}
	}	
	/* No Longer need the old array */
	free(node_arr);
	return new_node_arr;
}


/*
 * Finds the index of the new array and store the nodes from old array to new
 * array. Of course taking into account of chaining.
 *
 * Input:
 * 	Node *linked_nodes: the node that needs to be store to array
 * 	Node **node_array: array that is going to store the node
 * 	size_t: total index in the array
 *
 * Output:
 * 	None
 * */
void transfer(Node *linked_nodes, Node **node_array, size_t cap)
{
	size_t index;
	char *string;
	Node *node, *next_node;

	/* It existing list of nodes */
	node = linked_nodes;
	while(node->next != NULL)
	{
		/* Detach current node*/
		next_node = node->next;
		node->next = NULL;

		/* Get the index of the new array */
		string = node->string;
		index = hash_index(string, cap);
		
		/* Need chaining or not in the new size array */
		if(node_array[index] != NULL)
		{
			chain_node(node, node_array, index);
		}
		else
		{
			node_array[index] = node;
		}		
		/* Check for more chained nodes */
		node = next_node;
	}
	/* No more chained nodes or none to begin with */
	string = node->string;
	index = hash_index(string, cap);

	if(node_array[index] != NULL)
	{
		chain_node(node, node_array, index);
	}
	else
	{
		node_array[index] = node;
	}	
}


/*
 * Chain node to existing nodes
 *
 * Input:
 * 	Node *new_entry: node to be chain
 * 	Node **list_nodes: array that stores linked nodes
 * 	size_t index: the index of where existing linked nodes exist
 *
 * Output:
 * 	None	
 * */
void chain_node(Node *new_entry, Node **list_nodes, size_t index)
{
	/* Get the head of the link list in the array */
	Node *head;	
	
	/* Find the end of the list */	
	head = list_nodes[index];
	while(head->next != NULL)	
	{
		/* Keep going until end of list */
		head = head->next;
	}
	
	/* Should be at the end of the list by now */
	head->next = new_entry;
}


/*
 * Try to find if the given string exist in the given dictionary
 *
 * Input:
 * 	Dict *dct: target dictionary (hashmap)
 * 	char *str: desired string to find
 *
 * Output:
 * 	returns the Node that contains the target string
 * 	or return NULL if said string DNE (does not exist)
 * */
Node *nodelookup(Dict *dct, char *str)
{
	size_t index;
	Node *node_list, *return_node;

	index = hash_index(str, dct->cap);
	return_node = NULL;
	node_list = dct->arr[index];		

	/* Is there even a node? */
	while(node_list != NULL)
	{
		if(strcmp(node_list->string, str) == 0)	
		{ 
			return_node = node_list;
		}
		node_list = node_list->next;	
	}	
	return return_node;
}


